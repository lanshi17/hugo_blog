<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据库学习笔记 | lanshi个人博客</title>
<meta name=keywords content="学习打卡,数据库"><meta name=description content="这是我的第一篇学习日志。"><meta name=author content="lanshi"><link rel=canonical href=https://lanshi.xyz/studynotes/database/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lanshi.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lanshi.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lanshi.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://lanshi.xyz/apple-touch-icon.png><link rel=mask-icon href=https://lanshi.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://lanshi.xyz/studynotes/database/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-B5B8VFF5M8"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-B5B8VFF5M8")}</script><meta property="og:url" content="https://lanshi.xyz/studynotes/database/"><meta property="og:site_name" content="lanshi个人博客"><meta property="og:title" content="数据库学习笔记"><meta property="og:description" content="这是我的第一篇学习日志。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="studynotes"><meta property="article:tag" content="学习打卡"><meta property="article:tag" content="数据库"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据库学习笔记"><meta name=twitter:description content="这是我的第一篇学习日志。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Studynotes","item":"https://lanshi.xyz/studynotes/"},{"@type":"ListItem","position":2,"name":"数据库学习笔记","item":"https://lanshi.xyz/studynotes/database/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据库学习笔记","name":"数据库学习笔记","description":"这是我的第一篇学习日志。","keywords":["学习打卡","数据库"],"articleBody":"绪论 数据库的4个基本概念 数据data\n数据库database,DB\n数据库管理系统DBMS\n数据库系统DBS\n数据库系统的特点 结构化\n共享性高,低冗余,易扩充\n数据独立性高:物理;逻辑\n由DBMS统一管理和控制\n数据模型 概念模型-E-R图\n逻辑模型–关系模型\n物理模型\n数据模型的组成要素:数据结构,数据操作,数据的完整性约束条件 数据结构-静态\n数据操作-动态\n完整性约束条件\n重点:数据库系统的三级模式结构:外模式,模式(逻辑模式),内模式 外模式:外模式是用户或应用程序看到的局部数据逻辑结构，也称为用户视图。每个外模式为特定用户组定制，屏蔽了数据库的复杂结构。例如，不同用户可能通过不同的外模式访问同一数据库的不同部分。\n模式:模式是数据库的全局逻辑结构，定义所有数据实体、属性、关系及约束（如主键、外键）。例如，包含所有表的结构及其联系，是数据库设计的核心蓝图。\n内模式:内模式描述数据的物理存储方式，如文件组织、索引结构、数据压缩等。\n数据库的二级印象功能与逻辑独立性 外模式/模式:保证了数据的逻独立性\n模式/内模式:保证了 物理独立性\n数据库安全性(授权) 不安全因素 非法访问：未经授权的用户入侵数据库。\n恶意软件：病毒、木马等可能破坏数据完整性。\n数据泄露：配置不当或外部攻击导致敏感信息暴露。\n数据库安全性控制 用户身份认证与授权管理\n数据加密传输与存储\n安全审计与日志记录\n定期漏洞扫描与风险评估\n为什么授权? 授权是指授予(GRANT)和收回(REVOKE)，自主存取控制的方法，为了保护数据库防止不合法使用导致数据泄露、更改或破坏。\n如何授权:授予GRANT GRANT 权限 ON 对象类型 对象名 TO 用户名 [WITH GRANT OPTION]; 权限 数据库访问的各种操作权限，例如 SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, DROP，及ALL PRIVILEGES。\n对象类型 数据库中用于授权的对象类型，如 TABLE, DATABASE, VIEW, FUNCTION, PROCEDURE 等。\n对象名 具体数据库对象的名称，或使用*表示全局权限。\nTO 用户名 指定接受权限的用户或角色；多个用户可用逗号分隔。\nWITH GRANT OPTION 允许被授予权限的用户进一步将权限授权他人。\n示例 给用户 user1 授予 employees 表的 SELECT 权限:\nGRANT SELECT ON TABLE employees TO user1; 授予 user1 对整个数据库 testDB 查看所有表的 SELECT 权限：\nGRANT SELECT ON ALL TABLES IN SCHEMA testDB TO user1; 给用户 admin 授予所有权限并允许转授：\nGRANT ALL PRIVILEGES ON DATABASE testDB TO admin WITH GRANT OPTION; 注意: SQL 不允许循环授权（不能以下犯上）。\n收回授权:收回 REVOKE REVOKE 权限 ON 对象类型 对象名 FROM 用户名 [CASCADE][RESTRICT] 权限 用户在数据库中的操作许可，如 SELECT, INSERT, UPDATE, DELETE 等。\n对象类型 数据库中的对象，如 TABLE, VIEW, SEQUENCE, PROCEDURE 等。\n对象名 指定权限语句作用的特定对象名称。\n用户名 需要撤销权限的用户或角色。\nCASCADE 若该用户已将权限授予他人，则撤销时级联撤销所有相关权限。\nRESTRICT 若权限已被他人传递，将阻止撤销操作（CASCADE和RESTRICT只能选择一个）。\n示例 REVOKE SELECT ON TABLE employees FROM bob CASCADE; 该语句撤销用户 bob 的 SELECT 权限，同时撤销通过 bob 传递的相关权限。\n数据库完整性 三大完整性 实体完整性：保证每个表中记录的唯一性，通常通过主键约束实现，防止出现空值或重复值。\n参照完整性：确保外键值必须是在主键中存在的值，维护表间数据一致性。\n用户定义完整性：按照特定的业务规则，自定义数据的合法性约束，如自定义检查约束、触发器等。\n数据库编程 嵌入式SQL与主语言之间的通信 嵌入式SQL与主语言（如C、Java等）之间的通信主要通过以下几种方式进行：\nSQL $\\rightarrow$ 主语言：\n通信区（Communication Area, SQLCA）：用于报告SQL语句执行的状态和错误信息。SQLCA是一个结构体或类，包含了SQL语句的执行结果、错误码、警告等信息。通过检查SQLCA，主语言程序可以获取SQL语句的执行情况并作出相应的响应。 主语言 $\\rightarrow$ SQL：\n主变量（Host Variables）：主语言的变量可以直接用在嵌入式SQL语句中，将主语言的数据传递到数据库中。在SQL预处理阶段，这些变量会被相应地绑定到SQL语句中。 查询结果 $\\rightarrow$ 主语言：\n主变量和游标（Host Variables and Cursors）：查询结果可以通过主变量直接返回，也可以使用游标来遍历返回的结果集。游标允许主语言程序逐行访问SQL查询（如SELECT语句）的结果数据。 通信区（SQLCA）：\nSQLCA提供了一套结构化或对象化的方式来访问SQL语句执行后的状态和错误信息。具体的字段可能包括： SQLCODE（SQL代码）：指示了执行SQL操作的状态，正值表示警告，负值表示错误。 SQLERRM（错误信息）：包含了描述错误或状况的文本信息。 主变量：\n在嵌入式SQL中，可以声明与外部语言兼容的变量，这些变量可以用作输入参数发送到SQL，也可以作为输出接收查询结果的容器。 游标（Cursors）：\n游标是一个控制结构，允许对查询结果集进行逐行或批量操作。它包括声明、打开、获取数据、关闭等几个步骤： DECLARE：声明游标。 OPEN：打开游标执行查询。 FETCH：从游标中获取一行或多行数据。 CLOSE：关闭游标释放资源。 相关示例代码 下面是一个用C语言与嵌入式SQL（这里假设是使用了一种支持嵌入式SQL的编译器如Pro*C）的基本示例：\n#include #include EXEC SQL INCLUDE SQLCA;\r// 主变量声明\rint id;\rchar name[20];\rEXEC SQL BEGIN DECLARE SECTION;\rint ID;\rchar NAME[20];\rEXEC SQL END DECLARE SECTION;\rint main() {\rEXEC SQL WHENEVER SQLERROR GOTO error;\r// 从用户获取ID\rprintf(\"Enter ID: \");\rscanf(\"%d\", \u0026ID);\r// 查询语句，使用变量\rEXEC SQL SELECT name INTO :NAME FROM Employee WHERE id = :ID;\r// 打印结果\rprintf(\"Employee Name foram ID %d is %s\", ID, NAME);\rgoto end;\rerror:\rprintf(\"Error: %d - %s\", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);\rend:\rreturn 0;\r} 数据库设计的步骤 需求分析：明确用户需求、业务流程和数据量预估。\n概念结构设计：利用E-R图建立概念模型，确定实体、属性及实体间的关系。\n逻辑结构设计：将概念模型转换为逻辑模型，进行规范化处理，并设计相应的用户子模式。\n物理结构设计：确定数据存储结构，包括表结构、索引、分区及存储配置等。\n数据库实施：搭建数据库环境，部署数据库、数据迁移与初始化。\n数据库运行与维护：进行性能调优、数据备份、恢复策略、安全管理等。\n数据库恢复技术 事务的概念 数据库操作序列：定义事务为一组相关数据库操作的集合，作为一个整体执行。\n恢复的基本单位和并发控制的基本单位：确保在故障恢复时保持数据一致性和完整性。\n事务的SQL语句 提交：COMMIT\n回滚：ROLLBACK\n保存点：SAVEPOINT\n事务的四个特性 原子性\n一致性\n隔离性\n持续性\nDBS的故障种类 事务内部的故障\n系统故障（软故障，如软件错误）\n介质故障（硬故障，如硬盘损坏）\n计算机病毒及其他安全问题\n数据库恢复技术 数据转储：采用全量备份与增量备份策略，便于恢复最新数据。\n日志记录：登记日志文件，既可按记录为单位，也可按数据块为单位，辅助精确恢复。\n并发控制 并发控制的基本概念 并发控制：通过锁机制（悲观控制）或多版本控制（乐观控制）确保事务的一致性和隔离性。\n封锁：在悲观控制中，事务对数据项加锁，防止其他事务同时访问导致数据不一致。\n数据不一致性:\n丢失更新\n脏读\n不可重复读\n幻读\n封锁的基本概念 排他锁（X锁/写锁）：事务加锁后禁止其他事务对该数据项进行读写。\n共享锁（S锁/读锁）：允许其他事务同时加共享锁读取，但禁止加排他锁进行写操作。\\\n封锁协议 一级封锁协议：事务对数据项加锁后，直到事务结束才释放锁。\n严格两段锁协议（Strict 2PL）：事务在整个执行期间只在结束时统一释放所有锁，避免脏读问题。\n两段锁协议（2PL）：事务分为加锁阶段和解锁阶段，加锁阶段期间不释放锁，进入解锁阶段后不能再申请新锁。\n活锁和死锁 活锁：多个事务不断响应彼此的请求，导致无法有效推进。\n死锁：多个事务形成相互等待关系，导致系统僵持。\n死锁处理方法：\n死锁检测：构建等待图，检测循环依赖。\n死锁恢复：通过回滚部分事务解除死锁。\n死锁预防：采用资源排序、一次性申请所有资源等策略。\n可串行化调度 可串行化调度：事务执行顺序经过调整后效果等同于某一串行顺序，保证数据的一致性。\\\n两段锁协议(2PL) 两段锁协议：事务执行分为加锁阶段（不释放任何锁）和解锁阶段（统一释放所有锁）。\\\n多版本并发控制（MVCC） 多版本并发控制：通过保存数据的多个版本，使得读操作无需等待写锁，从而提高并发性能。常见于乐观并发控制策略。\\\n关系理论 函数依赖 非平凡的函数依赖: 对于函数依赖 $X \\rightarrow Y$, 若 $Y \\not\\subseteq X$, 则称为非平凡的函数依赖.\n平凡的函数依赖: 对于函数依赖 $X \\rightarrow Y$, 若 $Y \\subseteq X$, 则称为平凡的函数依赖.\n完全函数依赖: 若 $X \\rightarrow Y$成立, 且对于任意 $X$ 的真子集 $X’$, $X’ \\rightarrow Y$ 均不成立, 则称 $Y$ 对 $X$ 完全依赖.\n部分函数依赖: 若 $X \\rightarrow Y$成立, 且存在 $X’$ 为 $X$ 的真子集使得 $X’ \\rightarrow Y$ 成立, 则称 $Y$ 对 $X$ 部分依赖.\\\n码 候选码: 一个属性集合，满足该集合的属性闭包等于关系中的所有属性，且任一真子集的闭包不等于所有属性.\n求候选码的方法:\n确定必须包含的属性: 只出现在依赖左侧的属性或未在依赖中出现的属性.\n确定可能包含的属性: 同时出现在依赖左右两侧的属性.\n组合构造最小的属性集（候选码），其闭包为整个关系.\n例题:\n$R(A, B, C, D, E)$, $F = {A \\rightarrow B, B \\rightarrow C, C \\rightarrow D, D \\rightarrow E}$, 求候选码.\n答案: 候选码为${A}$\n证明: $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow E$.\n$R(A, B, C, D, E)$, $F = {A \\rightarrow B, B \\rightarrow C, C \\rightarrow D, D \\rightarrow E, A \\rightarrow D}$, 求候选码.\n答案: 候选码为${A}$\n证明: $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow E$ 以及 $A \\rightarrow D$.\n超码: 一个属性集合, 若其闭包包含关系中所有属性, 则称为超码.\n主码（码）: 最小的超码，即去除任一属性后闭包不再等于整个关系的属性集合.\n主属性: 属于主码的属性.\n非主属性: 不属于主码的属性.\n外码: 与其它关系候选码建立关联的属性集合.\n全码: 关系中所有属性组成的集合.\\\n范式 第一范式（1NF）: 关系中的每个属性都是不可再分的基本数据项.\n第二范式（2NF）: 关系中的每个非主属性完全依赖于任意一个候选码.\n第三范式（3NF）: 关系中的每个非主属性不传递依赖于任意一个候选码.\nBCNF: 关系中的每个属性都与候选码有直接关系.\n4NF: 关系中的每个多值依赖都是平凡的或者完全依赖于候选码.\n判断范式的方法:\n1NF: 检查是否有多值属性.\n2NF: 检查是否有部分依赖.\n3NF: 检查是否有传递依赖.\nBCNF: 检查是否有非平凡的函数依赖.\n4NF: 检查是否有多值依赖.\n分解关系的方法:画依赖图分析关系。 从低到高逐步分解，不要跳过步骤。\n分解关系的目的:\n保持函数依赖: 保持原关系中的所有函数依赖.\n保持连接性: 保持原关系中的所有元组.\n保持覆盖性: 保持原关系中的所有属性.\n最小函数依赖集 求最小函数依赖集的方法:\n拆分右侧多属性: 若 $X \\rightarrow Y$，则 $X \\rightarrow Y_i$.\n去除自身求闭包: 若 $X \\rightarrow Y$，则 $X$ 的真子集 $X’$ 不能决定 $Y$.\n左侧最小化: 若 $X \\rightarrow Y$，则 $X$ 的真子集 $X’$ 不能决定 $Y$.\n例题: 设 $R(A, B, C, D, E)$, $F = {C \\rightarrow A, CG \\rightarrow BD, CE \\rightarrow A, ACD \\rightarrow B}$, 求最小函数依赖集.\n解析:\n拆分右侧多属性: $CG \\rightarrow BD$ 可拆分为 $CG \\rightarrow B$ 和 $CG \\rightarrow D$.\n去除自身的依赖,求能不能闭包: 保留$C \\rightarrow A$,去掉$CG \\rightarrow B$,保留$CG \\rightarrow D$,去掉$CE \\rightarrow A$,保留$ACD \\rightarrow B$.\n左侧最小化: $ACD \\rightarrow B$ 可最小化为 $CD \\rightarrow B$.\n答案: 最小函数依赖集为${C \\rightarrow A,CG \\rightarrow D, CD \\rightarrow B}$.\n模式分解 判断无损连接分解的方法:\n画表格，列出原关系的所有属性.\n画表格，列出分解后的关系的所有属性.\n更新表格，列出所有属性的闭包.\n若闭包相等，则无损连接.\n例题: 设 $R(A, B, C, D, E)$, $F = {A \\rightarrow C, C \\rightarrow D, DE \\rightarrow C, CE \\rightarrow A}$, 求模式分解.\n解析:\n关系模式 $R(A, B, C, D, E)$ 在函数依赖集 $F = {A \\rightarrow C, C \\rightarrow D, DE \\rightarrow C, CE \\rightarrow A}$ 下的 3NF 分解 如下：\nDEC(D, E, C)\n包含函数依赖 $DE \\rightarrow C$ 和 $C \\rightarrow D$。\n候选键为 $DE$，满足 3NF。\nCEA(C, E, A)\n包含函数依赖 $CE \\rightarrow A$ 和 $A \\rightarrow C$。\n候选键为 $CE$，满足 3NF。\nBCE(B, C, E)\n包含候选键 $BCE$，确保无损连接。\n所有属性均为候选键的一部分，满足 3NF。\n分解步骤说明：\n确定候选键\n通过闭包计算，候选键为 $BCE$、$BDE$、$BAE$。所有候选键必须包含 $B$，因为 $B$ 无法通过其他属性推导。 构造 3NF 关系模式\n为每个函数依赖创建关系模式：\n$A \\rightarrow C$ 映射到 CEA（通过合并 $CE \\rightarrow A$）。\n$C \\rightarrow D$ 映射到 DEC（与 $DE \\rightarrow C$ 合并）。\n添加候选键关系模式 BCE。\n验证依赖保持与无损连接\n所有函数依赖均被保留在子模式中。\n候选键 $BCE$ 的存在保证了无损连接。\n答案:\n最终分解结果：\nDEC(D, E, C)\nCEA(C, E, A)\nBCE(B, C, E)\n该分解满足 3NF，保持所有函数依赖，并确保无损连接。\n关系语言 关系代数 集合运算 并: $$R \\cup S = {t \\mid t \\in R \\vee t \\in S}$$\n差: $$R - S = {t \\mid t \\in R \\wedge t \\notin S}$$\n交: $$R \\cap S = {t \\mid t \\in R \\wedge t \\in S}$$\n笛卡尔积: $$R \\times S = {t \\mid t = t_1 \\cup t_2,; t_1 \\in R,; t_2 \\in S}$$\n基本关系运算 选择: $$\\sigma_{\\text{条件}}(R)$$\n投影: $$\\pi_{\\text{属性列表}}(R)$$\n连接运算 连接: $R \\bowtie S$\n等值连接: $$R \\bowtie_{R.A = S.B} S$$ 设 $R$ 和 $S$ 分别为关系模式 $R(A_1, A_2, \\ldots, A_n)$ 和 $S(B_1, B_2, \\ldots, B_m)$，连接条件为 $R.A = S.B$。\n自然连接: $$R \\bowtie S$$ 系统自动使用 $R$ 与 $S$ 中同名的公共属性进行连接。\nTheta连接: $$R \\bowtie_{\\theta} S$$ 其中 $\\theta$ 为任意布尔表达式，如 $R.A \u003e S.B$。\n外连接:\n左外连接: $$R \\ \\text{⟕}\\ S$$ 返回 $R$ 中所有元组，对于在 $S$ 中没有匹配的元组，用空值（NULL）填充。\n右外连接: $$R \\ \\text{⟖}\\ S$$ 返回 $S$ 中所有元组，对于在 $R$ 中没有匹配的元组，用空值填充。\n全外连接: $$R \\ \\text{⟗}\\ S$$ 返回 $R$ 和 $S$ 中所有元组，对于没有匹配的一方用空值填充。\n除运算 除运算: $$R \\div S$$ 设 $R$ 为关系模式 $R(A_1, A_2, \\ldots, A_n)$，$S$ 为关系模式 $S(B_1, B_2, \\ldots, B_m)$，且 $S \\subseteq R$（即 $S$ 中的属性均属于 $R$），令 $T = R - S$，则得到： $$R \\div S = \\pi_T(R) - \\pi_T\\Big((\\pi_T(R) \\times S) - R\\Big)$$ 即返回所有在 $R$ 中出现的 $T$ 元组，使得对于 $S$ 中的每个元组都存在与之联结的记录。 关系代数解题方法 常规解题方法 (求几个属性的特定值) 格式一般为: $$\\pi_{\\text{属性列表}}(\\sigma_{\\text{条件}}(R))$$ 步骤：\n根据题目要求确定选择条件（通常是某属性等于常数）。\n根据需要投影出指定的属性。\n除运算解题方法 例如：设 A 为学生选课表，B 为课程信息表，要求求选了所有课程的学生学号。\n求出 $R$ 中除课程号外的属性（例如学生学号）构成集合 $T$。\n构造笛卡尔积 $T \\times B$，并计算差集 $(T \\times B) - R$，找出哪些组合在选课表中没有出现。\n利用公式： $$\\pi_T(R) - \\pi_T\\Big((T \\times B) - R\\Big)$$ 得到所要求的学生学号。\n差运算解题方法 格式一般为: $$R - S$$ 步骤：\n求出 $R$ 中所有相关属性的元组集合。\n求出 $S$ 中的元组集合。\n用 $R - S$ 得到在 $R$ 中出现而在 $S$ 中未出现的元组。\n例如：设 A 为学生成绩表，要求求\"没有任何一门课程及格的学生姓名\"。\n求出学生成绩表中所有学生的姓名： $$\\pi_{\\text{姓名}}(student)$$\n求出所有及格（成绩 $\\geq 60$）学生的姓名： $$\\pi_{\\text{姓名}}(\\sigma_{\\text{成绩} \\geq 60}(student))$$\n运用差集得到没有及格的学生姓名： $$\\pi_{\\text{姓名}}(student) - \\pi_{\\text{姓名}}(\\sigma_{\\text{成绩} \\geq 60}(student))$$\n其它例题 查 student 表中 IS 系的全体学生的学号和姓名：\n从 student 表中投影出学号和姓名。\n选择出所在系为 IS 的记录。\n表达式： $$\\pi_{\\text{学号, 姓名}}(\\sigma_{\\text{所在系} = \\text{IS}}(student))$$\n查 student 表中学号为 1 的学生的姓名和所在系：\n从 student 表中投影出学号、姓名和所在系。\n选择学号为 1 的记录。\n表达式： $$\\pi_{\\text{姓名, 所在系}}(\\sigma_{\\text{学号} = 1}(student))$$\n案:$\\pi_{\\text{姓名, 所在系}}(\\sigma_{\\text{学号} = 1}(student))$.\nSQL语句 定义基本表 CREATE TABLE CREATE TABLE 表名 (\r列名1 数据类型1 [约束条件1],\r列名2 数据类型2 [约束条件2],\r...\r列名n 数据类型n [约束条件n]\r表级约束条件1,\r表级约束条件2,\r...\r表级约束条件n\r);\r数据类型 CHAR(n): 定长字符串，n 为字符个数。\nVARCHAR(n): 变长字符串，最大长度为 n。\nNUMBER(n):长度为 n 的数字。\nINT: 整数, 4 字节。\nSMALLINT: 小整数, 2 字节。\nBIGINT: 大整数, 8 字节。\nFLOAT(n): 浮点数, n 为有效位数。\nDATE: 日期, 格式为 YYYY-MM-DD。\nTIME: 时间, 格式为 HH:MM:SS。\nTIMESTAMP: 时间戳, 格式为 YYYY-MM-DD HH:MM:SS。\n约束条件 NOT NULL: 非空。\nPRIMARY KEY: 主码,可以有多个列组成。\nUNIQUE: 唯一。\nFOREIGN KEY: 外键。\nCHECK: 检查约束。\n表级约束条件 PRIMARY KEY(列名1, 列名2, ..., 列名n): 主码。\nUNIQUE(列名1, 列名2, ..., 列名n): 唯一。\nFOREIGN KEY(列名1, 列名2, ..., 列名n) REFERENCES 表名(列名1, 列名2, ..., 列名n): 外键。\nCHECK(条件): 检查约束。\neg:\nCREATE TABLE student (\rsno CHAR(8),\rsname VARCHAR(20) NOT NULL,\rssex CHAR(2) CHECK(ssex IN ('男', '女')),\rsage SMALLINT CHECK(sage \u003e= 0 AND sage \u003c= 150),\rsdept VARCHAR(20),\rPRIMARY KEY(sno),\rUNIQUE(sname, ssex)\r);\r插入数据 INSERT INTO INSERT INTO 表名(列名1, 列名2, ..., 列名n) VALUES(值1, 值2, ..., 值n);\reg:\nINSERT INTO student(sno, sname, ssex, sage, sdept) VALUES('201215121', '李勇', '男', 20, '计算机系');\r删除数据 DELETE DELETE FROM 表名 WHERE 条件;\reg:注意完整性约束, 删除主码时, 会删除相关的外码。\nDELETE FROM student WHERE sno = '201215121';\r更新数据 UPDATE UPDATE 表名 SET 列名1 = 值1, 列名2 = 值2, ..., 列名n = 值n WHERE 条件;\reg:\nUPDATE student SET sdept = '电子系' WHERE sno = '201215121';\r查询数据 SELECT SELECT (DISTINCT) 列名1, 列名2, ..., 列名n // 查询的列,DISTINCT 可选项,去重, 默认不去重\rFROM 表名1, 表名2, ..., 表名n // 查询的表\rWHERE 条件 // 查询条件\rGROUP BY 列名1, 列名2, ..., 列名n // 分组\rORDER BY 列名1, 列名2, ..., 列名n; // 排序, 默认升序ASC, 降序加 DESC\reg:\nSELECT * FROM student WHERE sdept = '计算机系' ORDER BY sage DESC;\r聚合函数:当聚合函数遇到空值时,会忽略该值。聚合函数只能用于 SELECT 语句和GROUP BY 和 HAVING 子句中。\nCOUNT(列名): 计数。\nSUM(列名): 求和。\nAVG(列名): 平均值。\nMAX(列名): 最大值。\nMIN(列名): 最小值。\neg:\nSELECT COUNT(*), AVG(sage) FROM student WHERE sdept = '计算机系';//查询计算机系学生人数和平均年龄\rwhere 条件:\n列名 = 值: 等于。\n列名 \u003c\u003e 值: 不等于。\n列名 \u003e 值: 大于。\n列名 \u003c 值: 小于。\n列名 \u003e= 值: 大于等于。\n列名 \u003c= 值: 小于等于。\n列名 BETWEEN 值1 AND 值2: 在值1和值2之间。\n列名 NOT BETWEEN 值1 AND 值2: 不在值1和值2之间。\n列名 AND 列名: 与。\n列名 OR 列名: 或。\n列名 IS NULL: 为空。\n列名 IS NOT NULL: 不为空。\n列名 IN (值1, 值2, ..., 值n): 在值1, 值2, ..., 值n中。\n列名 LIKE 模式: 模糊查询。\neg:\nSELECT sdept, COUNT(*), AVG(sage) FROM student WHERE sage \u003e 20 GROUP BY sdept HAVING COUNT(*) \u003e 2 ORDER BY sdept;//查询年龄大于20的学生各系人数和平均年龄, 人数大于2的系\r字符匹配模式:在ASCII字符集中, 一个汉字占两个字符, 一个字母占一个字符。在GBK字符集中, 一个汉字占两个字符, 一个字母占一个字符。在UTF-8字符集中, 一个汉字占三个字符, 一个字母占一个字符。在UTF-16字符集中, 一个汉字占两个字符, 一个字母占两个字符。 通配符:\n%: 任意字符。\n_: 单个字符。\n转义字符\\:在模糊查询中, %和_是通配符, 如果要查询这两个字符, 需要使用转义字符。 eg:\nSELECT * FROM student WHERE sname LIKE '李%';//查询姓李的学生\rGROUP BY 子句:对查询结果进行分组, 通常与聚合函数一起使用。 HAVING 子句:对分组后的结果进行筛选。\nSELECT 列名1, 列名2, ..., 列名n, 聚合函数1, 聚合函数2, ..., 聚合函数n\rFROM 表名1, 表名2, ..., 表名n\rWHERE 条件\rGROUP BY 列名1, 列名2, ..., 列名n\rHAVING 条件\reg:\nSELECT sdept, COUNT(*), AVG(sage) FROM student GROUP BY sdept HAVING COUNT(*) \u003e 2 ORDER BY sdept;//查询各系人数和平均年龄, 人数大于2的系\rORDER BY 子句:对查询结果进行排序。\nSELECT 列名1, 列名2, ..., 列名n\rFROM 表名1, 表名2, ..., 表名n\rWHERE 条件\rORDER BY 列名1, 列名2, ..., 列名n;\reg:\nSELECT * FROM student ORDER BY sage DESC;//按年龄降序排序\r连接查询 两表连接查询:\nSELECT 列名1, 列名2, ..., 列名n\rFROM 表名1, 表名2\rWHERE 表名1.列名 = 表名2.列名;\reg:\nSELECT student.sno, student.sname, student.sdept, course.cname, score.degree FROM student, course, score WHERE student.sno = score.sno AND course.cno = score.cno;//查询学生的学号, 姓名, 课程名, 成绩\r单表自连接查询:\nSELECT 列名1, 列名2, ..., 列名n\rFROM 表名1 别名1, 表名1 别名2\rWHERE 别名1.列名 = 别名2.列名;\reg:\nSELECT a.sno, a.sname, b.sname FROM student a, student b WHERE a.sdept = b.sdept AND a.sname \u003c\u003e b.sname;//查询同系不同名的学生\r外连接查询:\nSELECT 列名1, 列名2, ..., 列名n\rFROM 表名1 LEFT JOIN 表名2 ON 表名1.列名 = 表名2.列名;\reg:\nSELECT student.sno, student.sname, score.degree FROM student LEFT JOIN score ON student.sno = score.sno;//查询学生的学号, 姓名, 成绩\r嵌套查询 子查询 SELECT 列名1, 列名2, ..., 列名n\rFROM 表名\rWHERE 列名 IN (SELECT 列名 FROM 表名 WHERE 条件);\reg:\nSELECT * FROM student WHERE sdept IN (SELECT sdept FROM student WHERE sname = '李勇');//查询和李勇同系的学生\r比较子查询 SELECT 列名1, 列名2, ..., 列名n\rFROM 表名1\rWHERE 列名 运算符 (SELECT 列名 FROM 表名2 WHERE 条件);\reg:\nSELECT * FROM student WHERE sage \u003e (SELECT AVG(sage) FROM student WHERE sdept = '计算机系');//查询计算机系年龄大于平均年龄的学生\r连接子查询 SELECT 列名1, 列名2, ..., 列名n\rFROM 表名1\rWHERE EXISTS (SELECT * FROM 表名2 WHERE 条件);\reg1:在SC表中查询至少选修了1号学生选修的全部课程(Cno)的学生的学号(Sno)。\nSELECT DISTINCT Sno\rFROM SC WHERE EXISTS (SELECT * FROM SC WHERE SC.Sno = Sno AND SC.Cno = 1); //查询至少选修了1号学生选修的全部课程的学生的学号\r集合查询 UNION SELECT 列名1, 列名2, ..., 列名n\rFROM 表名1\rUNION\rSELECT 列名1, 列名2, ..., 列名n\rFROM 表名2;\reg:\nSELECT sno FROM student WHERE sdept = '计算机系' UNION SELECT sno FROM student WHERE sdept = '电子系';//查询计算机系和电子系的学生学号\rINTERSECT SELECT 列名1, 列名2, ..., 列名n\rFROM 表名1\rINTERSECT\rSELECT 列名1, 列名2, ..., 列名n\rFROM 表名2;\reg:\nSELECT sno FROM student WHERE sdept = '计算机系' INTERSECT SELECT sno FROM student WHERE sdept = '电子系';//查询计算机系和电子系的学生学号\rVIEW 视图 视图是一个虚拟表, 由一个或多个表的行或列组成, 与基本表不同, 视图不存储数据, 而是根据定义视图的查询语句动态生成数据,无法对视图进行增删改操作。\nCREATE VIEW 视图名 AS SELECT 列名1, 列名2, ..., 列名n FROM 表名1, 表名2, ..., 表名n WHERE 条件;\reg:\nCREATE VIEW student_view AS SELECT sno, sname, ssex, sage, sdept FROM student WHERE sdept = '计算机系';//创建计算机系学生视图\r事务调度 事务调度的准则 一组事务的调度必须保证:\n包含的每个事务的操作指令.\n事务的操作指令的执行顺序.\n并行事务的调度必须保证:\n可串行化.\n事务的操作指令的执行结果与它们在某个串行调度中的执行结果相同.\n判断一个调度是否可串行化的充分条件:\n冲突可串行化.\n冲突操作: 两个事务中的操作指令, 一个读, 一个写, 且操作的数据对象相同.\n一个调度是冲突可串行化的, 当且仅当它是冲突可串行调度.\n封锁 X锁: 读写锁, 用于写操作.\nS锁: 读锁, 用于读操作.\n封锁协议:\n一级封锁协议: 写前加X锁, 读写后解锁,可防止丢失更新.\n二级封锁协议: 写前加X锁, 读前加S锁, 读完释放S锁,事务结束后解锁, 可防止丢失更新和读脏数据.\n三级封锁协议: 读前加S锁, 读写前加X锁, 读写后解锁, 可防止丢失更新, 读脏数据和不可重复读.\n注意:幻读和不可重复读的区别在于, 幻读是由于插入操作引起的, 不可重复读是由于更新操作引起的.\n两段锁协议(2PL): 事务的封锁和解锁操作必须在事务的开始和结束时进行.\neg. A的初始值为20, B的初始值为10, X,Y为临时变量,X=R(A)表示从A中读取数据到X中, X=X-10表示X减10, W(A,X)表示将X写入A中, W(A，X)表示将X写入A中, Y=R(B)表示从B中读取数据到Y中, Y=Y*X表示Y乘以X, W(B,Y)表示将Y写入B中. 事务T1和T2的操作序列如下:\nT1 T2 X=R(A) Y=R(B) X=R(A) X=X-10 X=X+Y W(A,X) Y=R(B) W(A,X) Y=Y*X; W(B,Y) Q1:给出图中所示的执行结果(A,B的值),判定其是否正确,并说明理由.\n最终结果,A=20,B=200.\nQ2:加入适当的Xlock()和Unlock()操作,要求执行两段锁协议,且每个事务首条语句的请求时间与图示调度一致,请重写该调度,并给出执行结果.\n调度表格如下:\nT1 T2 Xlock(A) X=R(A) Xlock(A) Xlock(B) Y=R(B) X=X+Y W(A,X) Unlock(A) Unlock(B) X=X-10 W(A,X) Xlock(B) Y=R(B) Y=Y*X; W(B,Y) Unlock(A) Unlock(B) 最终结果,A=20,B=200.\n数据库设计 ER图 实体为矩形，属性为椭圆，关系为菱形。联系用线连接实体和关系，表示实体间的联系。关系有一对一、一对多、多对多三种情况。\n例题 ","wordCount":"1964","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"lanshi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lanshi.xyz/studynotes/database/"},"publisher":{"@type":"Organization","name":"lanshi个人博客","logo":{"@type":"ImageObject","url":"https://lanshi.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lanshi.xyz/ accesskey=h title="lanshi个人博客 (Alt + H)">lanshi个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lanshi.xyz/resume/ title=简历><span>简历</span></a></li><li><a href=https://lanshi.xyz/portfolio/ title=作品集><span>作品集</span></a></li><li><a href=https://lanshi.xyz/studynotes/ title=学习笔记><span>学习笔记</span></a></li><li><a href=https://lanshi.xyz/posts/ title=文章><span>文章</span></a></li><li><a href=https://lanshi.xyz/categories/ title=分类><span>分类</span></a></li><li><a href=https://lanshi.xyz/tags/ title=标签><span>标签</span></a></li><li><a href=https://lanshi.xyz/archives title=归档><span>归档</span></a></li><li><a href=https://lanshi.xyz/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lanshi.xyz/>主页</a>&nbsp;»&nbsp;<a href=https://lanshi.xyz/studynotes/>Studynotes</a></div><h1 class="post-title entry-hint-parent">数据库学习笔记</h1><div class=post-meta>10 分钟&nbsp;·&nbsp;1964 字&nbsp;·&nbsp;lanshi&nbsp;|&nbsp;<a href=https://github.com/lanshi47/hugo_blog/tree/master/content/studynotes/database/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%bb%aa%e8%ae%ba aria-label=绪论>绪论</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%844%e4%b8%aa%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=数据库的4个基本概念>数据库的4个基本概念</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%89%b9%e7%82%b9 aria-label=数据库系统的特点>数据库系统的特点</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b aria-label=数据模型>数据模型</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e7%9a%84%e7%bb%84%e6%88%90%e8%a6%81%e7%b4%a0%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%95%b0%e6%8d%ae%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae%e7%9a%84%e5%ae%8c%e6%95%b4%e6%80%a7%e7%ba%a6%e6%9d%9f%e6%9d%a1%e4%bb%b6 aria-label=数据模型的组成要素:数据结构,数据操作,数据的完整性约束条件>数据模型的组成要素:数据结构,数据操作,数据的完整性约束条件</a></li><li><a href=#%e9%87%8d%e7%82%b9%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%89%e7%ba%a7%e6%a8%a1%e5%bc%8f%e7%bb%93%e6%9e%84%e5%a4%96%e6%a8%a1%e5%bc%8f%e6%a8%a1%e5%bc%8f%e9%80%bb%e8%be%91%e6%a8%a1%e5%bc%8f%e5%86%85%e6%a8%a1%e5%bc%8f aria-label=重点:数据库系统的三级模式结构:外模式,模式(逻辑模式),内模式>重点:数据库系统的三级模式结构:外模式,模式(逻辑模式),内模式</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%ba%8c%e7%ba%a7%e5%8d%b0%e8%b1%a1%e5%8a%9f%e8%83%bd%e4%b8%8e%e9%80%bb%e8%be%91%e7%8b%ac%e7%ab%8b%e6%80%a7 aria-label=数据库的二级印象功能与逻辑独立性>数据库的二级印象功能与逻辑独立性</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%89%e5%85%a8%e6%80%a7%e6%8e%88%e6%9d%83 aria-label=数据库安全性(授权)>数据库安全性(授权)</a><ul><li><a href=#%e4%b8%8d%e5%ae%89%e5%85%a8%e5%9b%a0%e7%b4%a0 aria-label=不安全因素>不安全因素</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%89%e5%85%a8%e6%80%a7%e6%8e%a7%e5%88%b6 aria-label=数据库安全性控制>数据库安全性控制</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%8e%88%e6%9d%83 aria-label=为什么授权?>为什么授权?</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%8e%88%e6%9d%83%e6%8e%88%e4%ba%88grant aria-label=如何授权:授予GRANT>如何授权:授予GRANT</a><ul><ul><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a></li></ul></ul></li><li><a href=#%e6%94%b6%e5%9b%9e%e6%8e%88%e6%9d%83%e6%94%b6%e5%9b%9e-revoke aria-label="收回授权:收回 REVOKE">收回授权:收回 REVOKE</a><ul><ul><li><a href=#%e6%9d%83%e9%99%90 aria-label=权限>权限</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b aria-label=对象类型>对象类型</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e5%90%8d aria-label=对象名>对象名</a></li><li><a href=#%e7%94%a8%e6%88%b7%e5%90%8d aria-label=用户名>用户名</a></li><li><a href=#cascade aria-label=CASCADE>CASCADE</a></li><li><a href=#restrict aria-label=RESTRICT>RESTRICT</a></li><li><a href=#%e7%a4%ba%e4%be%8b-1 aria-label=示例>示例</a></li></ul></ul></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%8c%e6%95%b4%e6%80%a7 aria-label=数据库完整性>数据库完整性</a><ul><li><a href=#%e4%b8%89%e5%a4%a7%e5%ae%8c%e6%95%b4%e6%80%a7 aria-label=三大完整性>三大完整性</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bc%96%e7%a8%8b aria-label=数据库编程>数据库编程</a><ul><li><a href=#%e5%b5%8c%e5%85%a5%e5%bc%8fsql%e4%b8%8e%e4%b8%bb%e8%af%ad%e8%a8%80%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1 aria-label=嵌入式SQL与主语言之间的通信>嵌入式SQL与主语言之间的通信</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 aria-label=相关示例代码>相关示例代码</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e6%ad%a5%e9%aa%a4 aria-label=数据库设计的步骤>数据库设计的步骤</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%81%a2%e5%a4%8d%e6%8a%80%e6%9c%af aria-label=数据库恢复技术>数据库恢复技术</a><ul><li><a href=#%e4%ba%8b%e5%8a%a1%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label=事务的概念>事务的概念</a></li><li><a href=#%e4%ba%8b%e5%8a%a1%e7%9a%84sql%e8%af%ad%e5%8f%a5 aria-label=事务的SQL语句>事务的SQL语句</a></li><li><a href=#%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%9b%9b%e4%b8%aa%e7%89%b9%e6%80%a7 aria-label=事务的四个特性>事务的四个特性</a></li><li><a href=#dbs%e7%9a%84%e6%95%85%e9%9a%9c%e7%a7%8d%e7%b1%bb aria-label=DBS的故障种类>DBS的故障种类</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%81%a2%e5%a4%8d%e6%8a%80%e6%9c%af-1 aria-label=数据库恢复技术>数据库恢复技术</a></li></ul></li><li><a href=#%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6 aria-label=并发控制>并发控制</a><ul><li><a href=#%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=并发控制的基本概念>并发控制的基本概念</a></li><li><a href=#%e5%b0%81%e9%94%81%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=封锁的基本概念>封锁的基本概念</a></li><li><a href=#%e5%b0%81%e9%94%81%e5%8d%8f%e8%ae%ae aria-label=封锁协议>封锁协议</a></li><li><a href=#%e6%b4%bb%e9%94%81%e5%92%8c%e6%ad%bb%e9%94%81 aria-label=活锁和死锁>活锁和死锁</a></li><li><a href=#%e5%8f%af%e4%b8%b2%e8%a1%8c%e5%8c%96%e8%b0%83%e5%ba%a6 aria-label=可串行化调度>可串行化调度</a></li><li><a href=#%e4%b8%a4%e6%ae%b5%e9%94%81%e5%8d%8f%e8%ae%ae2pl aria-label=两段锁协议(2PL)>两段锁协议(2PL)</a></li><li><a href=#%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6mvcc aria-label=多版本并发控制（MVCC）>多版本并发控制（MVCC）</a></li></ul></li><li><a href=#%e5%85%b3%e7%b3%bb%e7%90%86%e8%ae%ba aria-label=关系理论>关系理论</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e4%be%9d%e8%b5%96 aria-label=函数依赖>函数依赖</a></li><li><a href=#%e7%a0%81 aria-label=码>码</a></li><li><a href=#%e8%8c%83%e5%bc%8f aria-label=范式>范式</a></li><li><a href=#%e6%9c%80%e5%b0%8f%e5%87%bd%e6%95%b0%e4%be%9d%e8%b5%96%e9%9b%86 aria-label=最小函数依赖集>最小函数依赖集</a></li><li><a href=#%e6%a8%a1%e5%bc%8f%e5%88%86%e8%a7%a3 aria-label=模式分解>模式分解</a></li></ul></li><li><a href=#%e5%85%b3%e7%b3%bb%e8%af%ad%e8%a8%80 aria-label=关系语言>关系语言</a><ul><li><a href=#%e5%85%b3%e7%b3%bb%e4%bb%a3%e6%95%b0 aria-label=关系代数>关系代数</a><ul><li><a href=#%e9%9b%86%e5%90%88%e8%bf%90%e7%ae%97 aria-label=集合运算>集合运算</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97 aria-label=基本关系运算>基本关系运算</a></li><li><a href=#%e8%bf%9e%e6%8e%a5%e8%bf%90%e7%ae%97 aria-label=连接运算>连接运算</a></li><li><a href=#%e9%99%a4%e8%bf%90%e7%ae%97 aria-label=除运算>除运算</a></li><li><a href=#%e5%85%b3%e7%b3%bb%e4%bb%a3%e6%95%b0%e8%a7%a3%e9%a2%98%e6%96%b9%e6%b3%95 aria-label=关系代数解题方法>关系代数解题方法</a><ul><li><a href=#%e5%b8%b8%e8%a7%84%e8%a7%a3%e9%a2%98%e6%96%b9%e6%b3%95-%e6%b1%82%e5%87%a0%e4%b8%aa%e5%b1%9e%e6%80%a7%e7%9a%84%e7%89%b9%e5%ae%9a%e5%80%bc aria-label="常规解题方法 (求几个属性的特定值)">常规解题方法 (求几个属性的特定值)</a></li><li><a href=#%e9%99%a4%e8%bf%90%e7%ae%97%e8%a7%a3%e9%a2%98%e6%96%b9%e6%b3%95 aria-label=除运算解题方法>除运算解题方法</a></li><li><a href=#%e5%b7%ae%e8%bf%90%e7%ae%97%e8%a7%a3%e9%a2%98%e6%96%b9%e6%b3%95 aria-label=差运算解题方法>差运算解题方法</a></li><li><a href=#%e5%85%b6%e5%ae%83%e4%be%8b%e9%a2%98 aria-label=其它例题>其它例题</a></li></ul></li></ul></li></ul></li><li><a href=#sql%e8%af%ad%e5%8f%a5 aria-label=SQL语句>SQL语句</a><ul><li><a href=#%e5%ae%9a%e4%b9%89%e5%9f%ba%e6%9c%ac%e8%a1%a8-create-table aria-label="定义基本表 CREATE TABLE">定义基本表 CREATE TABLE</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=数据类型>数据类型</a></li><li><a href=#%e7%ba%a6%e6%9d%9f%e6%9d%a1%e4%bb%b6 aria-label=约束条件>约束条件</a></li><li><a href=#%e8%a1%a8%e7%ba%a7%e7%ba%a6%e6%9d%9f%e6%9d%a1%e4%bb%b6 aria-label=表级约束条件>表级约束条件</a></li></ul></li><li><a href=#%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae-insert-into aria-label="插入数据 INSERT INTO">插入数据 INSERT INTO</a></li><li><a href=#%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae-delete aria-label="删除数据 DELETE">删除数据 DELETE</a></li><li><a href=#%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae-update aria-label="更新数据 UPDATE">更新数据 UPDATE</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e6%95%b0%e6%8d%ae-select aria-label="查询数据 SELECT">查询数据 SELECT</a></li><li><a href=#%e8%bf%9e%e6%8e%a5%e6%9f%a5%e8%af%a2 aria-label=连接查询>连接查询</a></li><li><a href=#%e5%b5%8c%e5%a5%97%e6%9f%a5%e8%af%a2 aria-label=嵌套查询>嵌套查询</a><ul><li><a href=#%e5%ad%90%e6%9f%a5%e8%af%a2 aria-label=子查询>子查询</a></li><li><a href=#%e6%af%94%e8%be%83%e5%ad%90%e6%9f%a5%e8%af%a2 aria-label=比较子查询>比较子查询</a></li><li><a href=#%e8%bf%9e%e6%8e%a5%e5%ad%90%e6%9f%a5%e8%af%a2 aria-label=连接子查询>连接子查询</a></li></ul></li><li><a href=#%e9%9b%86%e5%90%88%e6%9f%a5%e8%af%a2 aria-label=集合查询>集合查询</a><ul><li><a href=#union aria-label=UNION>UNION</a></li><li><a href=#intersect aria-label=INTERSECT>INTERSECT</a></li></ul></li><li><a href=#view-%e8%a7%86%e5%9b%be aria-label="VIEW 视图">VIEW 视图</a></li></ul></li><li><a href=#%e4%ba%8b%e5%8a%a1%e8%b0%83%e5%ba%a6 aria-label=事务调度>事务调度</a><ul><li><a href=#%e4%ba%8b%e5%8a%a1%e8%b0%83%e5%ba%a6%e7%9a%84%e5%87%86%e5%88%99 aria-label=事务调度的准则>事务调度的准则</a></li><li><a href=#%e5%b0%81%e9%94%81 aria-label=封锁>封锁</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1 aria-label=数据库设计>数据库设计</a><ul><li><a href=#er%e5%9b%be aria-label=ER图>ER图</a><ul><li><a href=#%e4%be%8b%e9%a2%98 aria-label=例题>例题</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=绪论>绪论<a hidden class=anchor aria-hidden=true href=#绪论>#</a></h1><h2 id=数据库的4个基本概念>数据库的4个基本概念<a hidden class=anchor aria-hidden=true href=#数据库的4个基本概念>#</a></h2><ol><li><p>数据data</p></li><li><p>数据库database,DB</p></li><li><p>数据库管理系统DBMS</p></li><li><p>数据库系统DBS</p></li></ol><h2 id=数据库系统的特点>数据库系统的特点<a hidden class=anchor aria-hidden=true href=#数据库系统的特点>#</a></h2><ol><li><p>结构化</p></li><li><p>共享性高,低冗余,易扩充</p></li><li><p>数据独立性高:物理;逻辑</p></li><li><p>由DBMS统一管理和控制</p></li></ol><h2 id=数据模型>数据模型<a hidden class=anchor aria-hidden=true href=#数据模型>#</a></h2><ol><li><p>概念模型-E-R图</p></li><li><p>逻辑模型&ndash;关系模型</p></li><li><p>物理模型</p></li></ol><h2 id=数据模型的组成要素数据结构数据操作数据的完整性约束条件>数据模型的组成要素:数据结构,数据操作,数据的完整性约束条件<a hidden class=anchor aria-hidden=true href=#数据模型的组成要素数据结构数据操作数据的完整性约束条件>#</a></h2><ol><li><p>数据结构-静态</p></li><li><p>数据操作-动态</p></li><li><p>完整性约束条件</p></li></ol><h2 id=重点数据库系统的三级模式结构外模式模式逻辑模式内模式><strong>重点:数据库系统的三级模式结构:外模式,模式(逻辑模式),内模式</strong><a hidden class=anchor aria-hidden=true href=#重点数据库系统的三级模式结构外模式模式逻辑模式内模式>#</a></h2><ol><li><p>外模式:外模式是用户或应用程序看到的局部数据逻辑结构，也称为用户视图。每个外模式为特定用户组定制，屏蔽了数据库的复杂结构。例如，不同用户可能通过不同的外模式访问同一数据库的不同部分。</p></li><li><p>模式:模式是数据库的全局逻辑结构，定义所有数据实体、属性、关系及约束（如主键、外键）。例如，包含所有表的结构及其联系，是数据库设计的核心蓝图。</p></li><li><p>内模式:内模式描述数据的物理存储方式，如文件组织、索引结构、数据压缩等。</p></li></ol><h2 id=数据库的二级印象功能与逻辑独立性>数据库的二级印象功能与逻辑独立性<a hidden class=anchor aria-hidden=true href=#数据库的二级印象功能与逻辑独立性>#</a></h2><ol><li><p>外模式/模式:保证了数据的逻独立性</p></li><li><p>模式/内模式:保证了 物理独立性</p></li></ol><h1 id=数据库安全性授权>数据库安全性(授权)<a hidden class=anchor aria-hidden=true href=#数据库安全性授权>#</a></h1><h2 id=不安全因素>不安全因素<a hidden class=anchor aria-hidden=true href=#不安全因素>#</a></h2><ol><li><p>非法访问：未经授权的用户入侵数据库。</p></li><li><p>恶意软件：病毒、木马等可能破坏数据完整性。</p></li><li><p>数据泄露：配置不当或外部攻击导致敏感信息暴露。</p></li></ol><h2 id=数据库安全性控制>数据库安全性控制<a hidden class=anchor aria-hidden=true href=#数据库安全性控制>#</a></h2><ul><li><p>用户身份认证与授权管理</p></li><li><p>数据加密传输与存储</p></li><li><p>安全审计与日志记录</p></li><li><p>定期漏洞扫描与风险评估</p></li></ul><h2 id=为什么授权><strong>为什么授权?</strong><a hidden class=anchor aria-hidden=true href=#为什么授权>#</a></h2><p><strong>授权是指授予(GRANT)和收回(REVOKE)，自主存取控制的方法，为了保护数据库防止不合法使用导致数据泄露、更改或破坏。</strong></p><h2 id=如何授权授予grant><strong>如何授权:授予GRANT</strong><a hidden class=anchor aria-hidden=true href=#如何授权授予grant>#</a></h2><pre tabindex=0><code>GRANT 权限 ON 对象类型 对象名 TO 用户名 [WITH GRANT OPTION];
</code></pre><dl><dt>权限</dt><dd><p>数据库访问的各种操作权限，例如 SELECT, INSERT, UPDATE, DELETE,
CREATE, ALTER, DROP，及ALL PRIVILEGES。</p></dd><dt>对象类型</dt><dd><p>数据库中用于授权的对象类型，如 TABLE, DATABASE, VIEW, FUNCTION,
PROCEDURE 等。</p></dd><dt>对象名</dt><dd><p>具体数据库对象的名称，或使用*表示全局权限。</p></dd><dt>TO 用户名</dt><dd><p>指定接受权限的用户或角色；多个用户可用逗号分隔。</p></dd><dt>WITH GRANT OPTION</dt><dd><p>允许被授予权限的用户进一步将权限授权他人。</p></dd></dl><h4 id=示例 class=unnumbered>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h4><ol><li><p>给用户 user1 授予 employees 表的 SELECT 权限:</p><pre tabindex=0><code>GRANT SELECT ON TABLE employees TO user1;
</code></pre></li><li><p>授予 user1 对整个数据库 testDB 查看所有表的 SELECT 权限：</p><pre tabindex=0><code>GRANT SELECT ON ALL TABLES IN SCHEMA testDB TO user1;
</code></pre></li><li><p>给用户 admin 授予所有权限并允许转授：</p><pre tabindex=0><code>GRANT ALL PRIVILEGES ON DATABASE testDB TO admin WITH GRANT OPTION;
</code></pre></li></ol><p><strong>注意:</strong> SQL 不允许循环授权（不能以下犯上）。</p><h2 id=收回授权收回-revoke>收回授权:收回 REVOKE<a hidden class=anchor aria-hidden=true href=#收回授权收回-revoke>#</a></h2><pre tabindex=0><code>REVOKE 权限 ON 对象类型 对象名 FROM 用户名 [CASCADE][RESTRICT]
</code></pre><h4 id=权限 class=unnumbered>权限<a hidden class=anchor aria-hidden=true href=#权限>#</a></h4><p>用户在数据库中的操作许可，如 SELECT, INSERT, UPDATE, DELETE 等。</p><h4 id=对象类型 class=unnumbered>对象类型<a hidden class=anchor aria-hidden=true href=#对象类型>#</a></h4><p>数据库中的对象，如 TABLE, VIEW, SEQUENCE, PROCEDURE 等。</p><h4 id=对象名 class=unnumbered>对象名<a hidden class=anchor aria-hidden=true href=#对象名>#</a></h4><p>指定权限语句作用的特定对象名称。</p><h4 id=用户名 class=unnumbered>用户名<a hidden class=anchor aria-hidden=true href=#用户名>#</a></h4><p>需要撤销权限的用户或角色。</p><h4 id=cascade class=unnumbered>CASCADE<a hidden class=anchor aria-hidden=true href=#cascade>#</a></h4><p>若该用户已将权限授予他人，则撤销时级联撤销所有相关权限。</p><h4 id=restrict class=unnumbered>RESTRICT<a hidden class=anchor aria-hidden=true href=#restrict>#</a></h4><p>若权限已被他人传递，将阻止撤销操作（CASCADE和RESTRICT只能选择一个）。</p><h4 id=示例-1 class=unnumbered>示例<a hidden class=anchor aria-hidden=true href=#示例-1>#</a></h4><pre tabindex=0><code>REVOKE SELECT ON TABLE employees FROM bob CASCADE;
</code></pre><p>该语句撤销用户 bob 的 SELECT 权限，同时撤销通过 bob 传递的相关权限。</p><h1 id=数据库完整性>数据库完整性<a hidden class=anchor aria-hidden=true href=#数据库完整性>#</a></h1><h2 id=三大完整性>三大完整性<a hidden class=anchor aria-hidden=true href=#三大完整性>#</a></h2><ol><li><p>实体完整性：保证每个表中记录的唯一性，通常通过主键约束实现，防止出现空值或重复值。</p></li><li><p>参照完整性：确保外键值必须是在主键中存在的值，维护表间数据一致性。</p></li><li><p>用户定义完整性：按照特定的业务规则，自定义数据的合法性约束，如自定义检查约束、触发器等。</p></li></ol><h1 id=数据库编程>数据库编程<a hidden class=anchor aria-hidden=true href=#数据库编程>#</a></h1><h2 id=嵌入式sql与主语言之间的通信>嵌入式SQL与主语言之间的通信<a hidden class=anchor aria-hidden=true href=#嵌入式sql与主语言之间的通信>#</a></h2><p>嵌入式SQL与主语言（如C、Java等）之间的通信主要通过以下几种方式进行：</p><ol><li><p><strong>SQL $\rightarrow$ 主语言</strong>：</p><ul><li><strong>通信区（Communication Area,
SQLCA）</strong>：用于报告SQL语句执行的状态和错误信息。SQLCA是一个结构体或类，包含了SQL语句的执行结果、错误码、警告等信息。通过检查SQLCA，主语言程序可以获取SQL语句的执行情况并作出相应的响应。</li></ul></li><li><p><strong>主语言 $\rightarrow$ SQL</strong>：</p><ul><li><strong>主变量（Host
Variables）</strong>：主语言的变量可以直接用在嵌入式SQL语句中，将主语言的数据传递到数据库中。在SQL预处理阶段，这些变量会被相应地绑定到SQL语句中。</li></ul></li><li><p><strong>查询结果 $\rightarrow$ 主语言</strong>：</p><ul><li><strong>主变量和游标（Host Variables and
Cursors）</strong>：查询结果可以通过主变量直接返回，也可以使用游标来遍历返回的结果集。游标允许主语言程序逐行访问SQL查询（如SELECT语句）的结果数据。</li></ul></li></ol><p><strong>通信区（SQLCA）</strong>：</p><ul><li>SQLCA提供了一套结构化或对象化的方式来访问SQL语句执行后的状态和错误信息。具体的字段可能包括：
SQLCODE（SQL代码）：指示了执行SQL操作的状态，正值表示警告，负值表示错误。
SQLERRM（错误信息）：包含了描述错误或状况的文本信息。</li></ul><p><strong>主变量</strong>：</p><ul><li>在嵌入式SQL中，可以声明与外部语言兼容的变量，这些变量可以用作输入参数发送到SQL，也可以作为输出接收查询结果的容器。</li></ul><p><strong>游标（Cursors）</strong>：</p><ul><li>游标是一个控制结构，允许对查询结果集进行逐行或批量操作。它包括声明、打开、获取数据、关闭等几个步骤：
<code>DECLARE</code>：声明游标。 <code>OPEN</code>：打开游标执行查询。
<code>FETCH</code>：从游标中获取一行或多行数据。 <code>CLOSE</code>：关闭游标释放资源。</li></ul><h2 id=相关示例代码>相关示例代码<a hidden class=anchor aria-hidden=true href=#相关示例代码>#</a></h2><p>下面是一个用C语言与嵌入式SQL（这里假设是使用了一种支持嵌入式SQL的编译器如Pro*C）的基本示例：</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

EXEC SQL INCLUDE SQLCA;

// 主变量声明
int id;
char name[20];

EXEC SQL BEGIN DECLARE SECTION;
int ID;
char NAME[20];
EXEC SQL END DECLARE SECTION;

int main() {
    EXEC SQL WHENEVER SQLERROR GOTO error;

    // 从用户获取ID
    printf(&#34;Enter ID: &#34;);
    scanf(&#34;%d&#34;, &amp;ID);
    
    // 查询语句，使用变量
    EXEC SQL SELECT name INTO :NAME FROM Employee WHERE id = :ID;
    
    // 打印结果
    printf(&#34;Employee Name foram ID %d is %s&#34;, ID, NAME);
    
    goto end;

error:
    printf(&#34;Error: %d - %s&#34;, sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);

end:
    return 0;
}
</code></pre><h1 id=数据库设计的步骤>数据库设计的步骤<a hidden class=anchor aria-hidden=true href=#数据库设计的步骤>#</a></h1><ol><li><p>需求分析：明确用户需求、业务流程和数据量预估。</p></li><li><p>概念结构设计：利用E-R图建立概念模型，确定实体、属性及实体间的关系。</p></li><li><p>逻辑结构设计：将概念模型转换为逻辑模型，进行规范化处理，并设计相应的用户子模式。</p></li><li><p>物理结构设计：确定数据存储结构，包括表结构、索引、分区及存储配置等。</p></li><li><p>数据库实施：搭建数据库环境，部署数据库、数据迁移与初始化。</p></li><li><p>数据库运行与维护：进行性能调优、数据备份、恢复策略、安全管理等。</p></li></ol><h1 id=数据库恢复技术>数据库恢复技术<a hidden class=anchor aria-hidden=true href=#数据库恢复技术>#</a></h1><h2 id=事务的概念>事务的概念<a hidden class=anchor aria-hidden=true href=#事务的概念>#</a></h2><ol><li><p>数据库操作序列：定义事务为一组相关数据库操作的集合，作为一个整体执行。</p></li><li><p>恢复的基本单位和并发控制的基本单位：确保在故障恢复时保持数据一致性和完整性。</p></li></ol><h2 id=事务的sql语句>事务的SQL语句<a hidden class=anchor aria-hidden=true href=#事务的sql语句>#</a></h2><ul><li><p>提交：COMMIT</p></li><li><p>回滚：ROLLBACK</p></li><li><p>保存点：SAVEPOINT</p></li></ul><h2 id=事务的四个特性>事务的四个特性<a hidden class=anchor aria-hidden=true href=#事务的四个特性>#</a></h2><ol><li><p>原子性</p></li><li><p>一致性</p></li><li><p>隔离性</p></li><li><p>持续性</p></li></ol><h2 id=dbs的故障种类>DBS的故障种类<a hidden class=anchor aria-hidden=true href=#dbs的故障种类>#</a></h2><ol><li><p>事务内部的故障</p></li><li><p>系统故障（软故障，如软件错误）</p></li><li><p>介质故障（硬故障，如硬盘损坏）</p></li><li><p>计算机病毒及其他安全问题</p></li></ol><h2 id=数据库恢复技术-1>数据库恢复技术<a hidden class=anchor aria-hidden=true href=#数据库恢复技术-1>#</a></h2><ol><li><p>数据转储：采用全量备份与增量备份策略，便于恢复最新数据。</p></li><li><p>日志记录：登记日志文件，既可按记录为单位，也可按数据块为单位，辅助精确恢复。</p></li></ol><h1 id=并发控制>并发控制<a hidden class=anchor aria-hidden=true href=#并发控制>#</a></h1><h2 id=并发控制的基本概念>并发控制的基本概念<a hidden class=anchor aria-hidden=true href=#并发控制的基本概念>#</a></h2><p>并发控制：通过锁机制（悲观控制）或多版本控制（乐观控制）确保事务的一致性和隔离性。<br>封锁：在悲观控制中，事务对数据项加锁，防止其他事务同时访问导致数据不一致。<br>数据不一致性:</p><ol><li><p>丢失更新</p></li><li><p>脏读</p></li><li><p>不可重复读</p></li><li><p>幻读</p></li></ol><h2 id=封锁的基本概念>封锁的基本概念<a hidden class=anchor aria-hidden=true href=#封锁的基本概念>#</a></h2><p>排他锁（X锁/写锁）：事务加锁后禁止其他事务对该数据项进行读写。<br>共享锁（S锁/读锁）：允许其他事务同时加共享锁读取，但禁止加排他锁进行写操作。\</p><h2 id=封锁协议>封锁协议<a hidden class=anchor aria-hidden=true href=#封锁协议>#</a></h2><ol><li><p>一级封锁协议：事务对数据项加锁后，直到事务结束才释放锁。</p></li><li><p>严格两段锁协议（Strict
2PL）：事务在整个执行期间只在结束时统一释放所有锁，避免脏读问题。</p></li><li><p>两段锁协议（2PL）：事务分为加锁阶段和解锁阶段，加锁阶段期间不释放锁，进入解锁阶段后不能再申请新锁。</p></li></ol><h2 id=活锁和死锁>活锁和死锁<a hidden class=anchor aria-hidden=true href=#活锁和死锁>#</a></h2><p>活锁：多个事务不断响应彼此的请求，导致无法有效推进。<br>死锁：多个事务形成相互等待关系，导致系统僵持。<br>死锁处理方法：</p><ol><li><p>死锁检测：构建等待图，检测循环依赖。</p></li><li><p>死锁恢复：通过回滚部分事务解除死锁。</p></li><li><p>死锁预防：采用资源排序、一次性申请所有资源等策略。</p></li></ol><h2 id=可串行化调度>可串行化调度<a hidden class=anchor aria-hidden=true href=#可串行化调度>#</a></h2><p>可串行化调度：事务执行顺序经过调整后效果等同于某一串行顺序，保证数据的一致性。\</p><h2 id=两段锁协议2pl>两段锁协议(2PL)<a hidden class=anchor aria-hidden=true href=#两段锁协议2pl>#</a></h2><p>两段锁协议：事务执行分为加锁阶段（不释放任何锁）和解锁阶段（统一释放所有锁）。\</p><h2 id=多版本并发控制mvcc>多版本并发控制（MVCC）<a hidden class=anchor aria-hidden=true href=#多版本并发控制mvcc>#</a></h2><p>多版本并发控制：通过保存数据的多个版本，使得读操作无需等待写锁，从而提高并发性能。常见于乐观并发控制策略。\</p><h1 id=关系理论>关系理论<a hidden class=anchor aria-hidden=true href=#关系理论>#</a></h1><h2 id=函数依赖>函数依赖<a hidden class=anchor aria-hidden=true href=#函数依赖>#</a></h2><p>非平凡的函数依赖: 对于函数依赖 $X \rightarrow Y$, 若
$Y \not\subseteq X$, 则称为非平凡的函数依赖.<br>平凡的函数依赖: 对于函数依赖 $X \rightarrow Y$, 若 $Y \subseteq X$,
则称为平凡的函数依赖.<br>完全函数依赖: 若 $X \rightarrow Y$成立, 且对于任意 $X$ 的真子集 $X&rsquo;$,
$X&rsquo; \rightarrow Y$ 均不成立, 则称 $Y$ 对 $X$ 完全依赖.<br>部分函数依赖: 若 $X \rightarrow Y$成立, 且存在 $X&rsquo;$ 为 $X$ 的真子集使得
$X&rsquo; \rightarrow Y$ 成立, 则称 $Y$ 对 $X$ 部分依赖.\</p><h2 id=码>码<a hidden class=anchor aria-hidden=true href=#码>#</a></h2><p>候选码:
一个属性集合，满足该集合的属性闭包等于关系中的所有属性，且任一真子集的闭包不等于所有属性.<br>求候选码的方法:</p><ol><li><p>确定必须包含的属性: 只出现在依赖左侧的属性或未在依赖中出现的属性.</p></li><li><p>确定可能包含的属性: 同时出现在依赖左右两侧的属性.</p></li><li><p>组合构造最小的属性集（候选码），其闭包为整个关系.</p></li></ol><p>例题:</p><ol><li><p>$R(A, B, C, D, E)$,
$F = {A \rightarrow B, B \rightarrow C, C \rightarrow D, D \rightarrow E}$,
求候选码.<br>答案: 候选码为${A}$<br>证明: $A \rightarrow B \rightarrow C \rightarrow D \rightarrow E$.</p></li><li><p>$R(A, B, C, D, E)$,
$F = {A \rightarrow B, B \rightarrow C, C \rightarrow D, D \rightarrow E, A \rightarrow D}$,
求候选码.<br>答案: 候选码为${A}$<br>证明: $A \rightarrow B \rightarrow C \rightarrow D \rightarrow E$
以及 $A \rightarrow D$.</p></li></ol><p>超码: 一个属性集合, 若其闭包包含关系中所有属性, 则称为超码.<br>主码（码）: 最小的超码，即去除任一属性后闭包不再等于整个关系的属性集合.<br>主属性: 属于主码的属性.<br>非主属性: 不属于主码的属性.<br>外码: 与其它关系候选码建立关联的属性集合.<br>全码: 关系中所有属性组成的集合.\</p><h2 id=范式>范式<a hidden class=anchor aria-hidden=true href=#范式>#</a></h2><p>第一范式（1NF）: 关系中的每个属性都是不可再分的基本数据项.<br>第二范式（2NF）: 关系中的每个非主属性完全依赖于任意一个候选码.<br>第三范式（3NF）: 关系中的每个非主属性不传递依赖于任意一个候选码.<br>BCNF: 关系中的每个属性都与候选码有直接关系.<br>4NF: 关系中的每个多值依赖都是平凡的或者完全依赖于候选码.<br>判断范式的方法:</p><ol><li><p>1NF: 检查是否有多值属性.</p></li><li><p>2NF: 检查是否有部分依赖.</p></li><li><p>3NF: 检查是否有传递依赖.</p></li><li><p>BCNF: 检查是否有非平凡的函数依赖.</p></li><li><p>4NF: 检查是否有多值依赖.</p></li></ol><p>分解关系的方法:画依赖图分析关系。 从低到高逐步分解，不要跳过步骤。<br>分解关系的目的:</p><ol><li><p>保持函数依赖: 保持原关系中的所有函数依赖.</p></li><li><p>保持连接性: 保持原关系中的所有元组.</p></li><li><p>保持覆盖性: 保持原关系中的所有属性.</p></li></ol><h2 id=最小函数依赖集>最小函数依赖集<a hidden class=anchor aria-hidden=true href=#最小函数依赖集>#</a></h2><p>求最小函数依赖集的方法:</p><ol><li><p>拆分右侧多属性: 若 $X \rightarrow Y$，则 $X \rightarrow Y_i$.</p></li><li><p>去除自身求闭包: 若 $X \rightarrow Y$，则 $X$ 的真子集 $X&rsquo;$ 不能决定
$Y$.</p></li><li><p>左侧最小化: 若 $X \rightarrow Y$，则 $X$ 的真子集 $X&rsquo;$ 不能决定 $Y$.</p></li></ol><p>例题: 设 $R(A, B, C, D, E)$,
$F = {C \rightarrow A, CG \rightarrow BD, CE \rightarrow A, ACD \rightarrow B}$,
求最小函数依赖集.<br>解析:</p><ol><li><p>拆分右侧多属性: $CG \rightarrow BD$ 可拆分为 $CG \rightarrow B$ 和
$CG \rightarrow D$.</p></li><li><p>去除自身的依赖,求能不能闭包:
保留$C \rightarrow A$,去掉$CG \rightarrow B$,保留$CG \rightarrow D$,去掉$CE \rightarrow A$,保留$ACD \rightarrow B$.</p></li><li><p>左侧最小化: $ACD \rightarrow B$ 可最小化为 $CD \rightarrow B$.</p></li></ol><p>答案:
最小函数依赖集为${C \rightarrow A,CG \rightarrow D, CD \rightarrow B}$.</p><h2 id=模式分解>模式分解<a hidden class=anchor aria-hidden=true href=#模式分解>#</a></h2><p>判断无损连接分解的方法:</p><ol><li><p>画表格，列出原关系的所有属性.</p></li><li><p>画表格，列出分解后的关系的所有属性.</p></li><li><p>更新表格，列出所有属性的闭包.</p></li><li><p>若闭包相等，则无损连接.</p></li></ol><p>例题: 设 $R(A, B, C, D, E)$,
$F = {A \rightarrow C, C \rightarrow D, DE \rightarrow C, CE \rightarrow A}$,
求模式分解.<br>解析:</p><p>关系模式 $R(A, B, C, D, E)$ 在函数依赖集
$F = {A \rightarrow C, C \rightarrow D, DE \rightarrow C, CE \rightarrow A}$
下的 <strong>3NF 分解</strong> 如下：</p><ol><li><p><strong>DEC(D, E, C)</strong></p><ul><li><p>包含函数依赖 $DE \rightarrow C$ 和 $C \rightarrow D$。</p></li><li><p>候选键为 $DE$，满足 3NF。</p></li></ul></li><li><p><strong>CEA(C, E, A)</strong></p><ul><li><p>包含函数依赖 $CE \rightarrow A$ 和 $A \rightarrow C$。</p></li><li><p>候选键为 $CE$，满足 3NF。</p></li></ul></li><li><p><strong>BCE(B, C, E)</strong></p><ul><li><p>包含候选键 $BCE$，确保无损连接。</p></li><li><p>所有属性均为候选键的一部分，满足 3NF。</p></li></ul></li></ol><p><strong>分解步骤说明：</strong></p><ol><li><p><strong>确定候选键</strong></p><ul><li>通过闭包计算，候选键为 $BCE$、$BDE$、$BAE$。所有候选键必须包含
$B$，因为 $B$ 无法通过其他属性推导。</li></ul></li><li><p><strong>构造 3NF 关系模式</strong></p><ul><li><p>为每个函数依赖创建关系模式：</p><ul><li><p>$A \rightarrow C$ 映射到 <strong>CEA</strong>（通过合并
$CE \rightarrow A$）。</p></li><li><p>$C \rightarrow D$ 映射到 <strong>DEC</strong>（与 $DE \rightarrow C$
合并）。</p></li><li><p>添加候选键关系模式 <strong>BCE</strong>。</p></li></ul></li></ul></li><li><p><strong>验证依赖保持与无损连接</strong></p><ul><li><p>所有函数依赖均被保留在子模式中。</p></li><li><p>候选键 $BCE$ 的存在保证了无损连接。</p></li></ul></li></ol><p>答案:<br><strong>最终分解结果：</strong></p><ul><li><p><strong>DEC(D, E, C)</strong></p></li><li><p><strong>CEA(C, E, A)</strong></p></li><li><p><strong>BCE(B, C, E)</strong></p></li></ul><p>该分解满足 3NF，保持所有函数依赖，并确保无损连接。</p><h1 id=关系语言>关系语言<a hidden class=anchor aria-hidden=true href=#关系语言>#</a></h1><h2 id=关系代数>关系代数<a hidden class=anchor aria-hidden=true href=#关系代数>#</a></h2><h3 id=集合运算>集合运算<a hidden class=anchor aria-hidden=true href=#集合运算>#</a></h3><ul><li><p>并: $$R \cup S = {t \mid t \in R \vee t \in S}$$</p></li><li><p>差: $$R - S = {t \mid t \in R \wedge t \notin S}$$</p></li><li><p>交: $$R \cap S = {t \mid t \in R \wedge t \in S}$$</p></li><li><p>笛卡尔积:
$$R \times S = {t \mid t = t_1 \cup t_2,; t_1 \in R,; t_2 \in S}$$</p></li></ul><h3 id=基本关系运算>基本关系运算<a hidden class=anchor aria-hidden=true href=#基本关系运算>#</a></h3><ul><li><p>选择: $$\sigma_{\text{条件}}(R)$$</p></li><li><p>投影: $$\pi_{\text{属性列表}}(R)$$</p></li></ul><h3 id=连接运算>连接运算<a hidden class=anchor aria-hidden=true href=#连接运算>#</a></h3><ul><li><p>连接: $R \bowtie S$</p><ul><li><p>等值连接: $$R \bowtie_{R.A = S.B} S$$ 设 $R$ 和 $S$
分别为关系模式 $R(A_1, A_2, \ldots, A_n)$ 和
$S(B_1, B_2, \ldots, B_m)$，连接条件为 $R.A = S.B$。</p></li><li><p>自然连接: $$R \bowtie S$$ 系统自动使用 $R$ 与 $S$
中同名的公共属性进行连接。</p></li><li><p>Theta连接: $$R \bowtie_{\theta} S$$ 其中 $\theta$
为任意布尔表达式，如 $R.A > S.B$。</p></li><li><p>外连接:</p><ul><li><p>左外连接: $$R \ \text{⟕}\ S$$ 返回 $R$ 中所有元组，对于在
$S$ 中没有匹配的元组，用空值（NULL）填充。</p></li><li><p>右外连接: $$R \ \text{⟖}\ S$$ 返回 $S$ 中所有元组，对于在
$R$ 中没有匹配的元组，用空值填充。</p></li><li><p>全外连接: $$R \ \text{⟗}\ S$$ 返回 $R$ 和 $S$
中所有元组，对于没有匹配的一方用空值填充。</p></li></ul></li></ul></li></ul><h3 id=除运算>除运算<a hidden class=anchor aria-hidden=true href=#除运算>#</a></h3><ul><li>除运算: $$R \div S$$ 设 $R$ 为关系模式
$R(A_1, A_2, \ldots, A_n)$，$S$ 为关系模式
$S(B_1, B_2, \ldots, B_m)$，且 $S \subseteq R$（即 $S$
中的属性均属于 $R$），令 $T = R - S$，则得到：
$$R \div S = \pi_T(R) - \pi_T\Big((\pi_T(R) \times S) - R\Big)$$
即返回所有在 $R$ 中出现的 $T$ 元组，使得对于 $S$
中的每个元组都存在与之联结的记录。</li></ul><h3 id=关系代数解题方法>关系代数解题方法<a hidden class=anchor aria-hidden=true href=#关系代数解题方法>#</a></h3><h4 id=常规解题方法-求几个属性的特定值>常规解题方法 (求几个属性的特定值)<a hidden class=anchor aria-hidden=true href=#常规解题方法-求几个属性的特定值>#</a></h4><p>格式一般为: $$\pi_{\text{属性列表}}(\sigma_{\text{条件}}(R))$$ 步骤：</p><ol><li><p>根据题目要求确定选择条件（通常是某属性等于常数）。</p></li><li><p>根据需要投影出指定的属性。</p></li></ol><h4 id=除运算解题方法>除运算解题方法<a hidden class=anchor aria-hidden=true href=#除运算解题方法>#</a></h4><p>例如：设 A 为学生选课表，B 为课程信息表，要求求选了所有课程的学生学号。</p><ol><li><p>求出 $R$ 中除课程号外的属性（例如学生学号）构成集合 $T$。</p></li><li><p>构造笛卡尔积 $T \times B$，并计算差集
$(T \times B) - R$，找出哪些组合在选课表中没有出现。</p></li><li><p>利用公式： $$\pi_T(R) - \pi_T\Big((T \times B) - R\Big)$$
得到所要求的学生学号。</p></li></ol><h4 id=差运算解题方法>差运算解题方法<a hidden class=anchor aria-hidden=true href=#差运算解题方法>#</a></h4><p>格式一般为: $$R - S$$ 步骤：</p><ol><li><p>求出 $R$ 中所有相关属性的元组集合。</p></li><li><p>求出 $S$ 中的元组集合。</p></li><li><p>用 $R - S$ 得到在 $R$ 中出现而在 $S$ 中未出现的元组。</p></li></ol><p>例如：设 A 为学生成绩表，要求求"没有任何一门课程及格的学生姓名"。</p><ol><li><p>求出学生成绩表中所有学生的姓名： $$\pi_{\text{姓名}}(student)$$</p></li><li><p>求出所有及格（成绩 $\geq 60$）学生的姓名：
$$\pi_{\text{姓名}}(\sigma_{\text{成绩} \geq 60}(student))$$</p></li><li><p>运用差集得到没有及格的学生姓名：
$$\pi_{\text{姓名}}(student) - \pi_{\text{姓名}}(\sigma_{\text{成绩} \geq 60}(student))$$</p></li></ol><h4 id=其它例题>其它例题<a hidden class=anchor aria-hidden=true href=#其它例题>#</a></h4><ol><li><p>查 student 表中 IS 系的全体学生的学号和姓名：</p><ol><li><p>从 student 表中投影出学号和姓名。</p></li><li><p>选择出所在系为 IS 的记录。</p></li></ol><p>表达式：
$$\pi_{\text{学号, 姓名}}(\sigma_{\text{所在系} = \text{IS}}(student))$$</p></li><li><p>查 student 表中学号为 1 的学生的姓名和所在系：</p><ol><li><p>从 student 表中投影出学号、姓名和所在系。</p></li><li><p>选择学号为 1 的记录。</p></li></ol><p>表达式：
$$\pi_{\text{姓名, 所在系}}(\sigma_{\text{学号} = 1}(student))$$</p></li></ol><p>案:$\pi_{\text{姓名, 所在系}}(\sigma_{\text{学号} = 1}(student))$.</p><h1 id=sql语句>SQL语句<a hidden class=anchor aria-hidden=true href=#sql语句>#</a></h1><h2 id=定义基本表-create-table>定义基本表 CREATE TABLE<a hidden class=anchor aria-hidden=true href=#定义基本表-create-table>#</a></h2><pre><code>CREATE TABLE 表名 (
    列名1 数据类型1 [约束条件1],
    列名2 数据类型2 [约束条件2],
    ...
    列名n 数据类型n [约束条件n]
    表级约束条件1,
    表级约束条件2,
    ...
    表级约束条件n
);
</code></pre><h3 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h3><ul><li><p>CHAR(n): 定长字符串，n 为字符个数。</p></li><li><p>VARCHAR(n): 变长字符串，最大长度为 n。</p></li><li><p>NUMBER(n):长度为 n 的数字。</p></li><li><p>INT: 整数, 4 字节。</p></li><li><p>SMALLINT: 小整数, 2 字节。</p></li><li><p>BIGINT: 大整数, 8 字节。</p></li><li><p>FLOAT(n): 浮点数, n 为有效位数。</p></li><li><p>DATE: 日期, 格式为 YYYY-MM-DD。</p></li><li><p>TIME: 时间, 格式为 HH:MM:SS。</p></li><li><p>TIMESTAMP: 时间戳, 格式为 YYYY-MM-DD HH:MM:SS。</p></li></ul><h3 id=约束条件>约束条件<a hidden class=anchor aria-hidden=true href=#约束条件>#</a></h3><ul><li><p>NOT NULL: 非空。</p></li><li><p>PRIMARY KEY: 主码,可以有多个列组成。</p></li><li><p>UNIQUE: 唯一。</p></li><li><p>FOREIGN KEY: 外键。</p></li><li><p>CHECK: 检查约束。</p></li></ul><h3 id=表级约束条件>表级约束条件<a hidden class=anchor aria-hidden=true href=#表级约束条件>#</a></h3><ul><li><p>PRIMARY KEY(列名1, 列名2, ..., 列名n): 主码。</p></li><li><p>UNIQUE(列名1, 列名2, ..., 列名n): 唯一。</p></li><li><p>FOREIGN KEY(列名1, 列名2, ..., 列名n) REFERENCES 表名(列名1, 列名2,
..., 列名n): 外键。</p></li><li><p>CHECK(条件): 检查约束。</p></li></ul><p>eg:</p><pre><code>CREATE TABLE student (
    sno CHAR(8),
    sname VARCHAR(20) NOT NULL,
    ssex CHAR(2) CHECK(ssex IN ('男', '女')),
    sage SMALLINT CHECK(sage &gt;= 0 AND sage &lt;= 150),
    sdept VARCHAR(20),
    PRIMARY KEY(sno),
    UNIQUE(sname, ssex)
);
</code></pre><h2 id=插入数据-insert-into>插入数据 INSERT INTO<a hidden class=anchor aria-hidden=true href=#插入数据-insert-into>#</a></h2><pre><code>INSERT INTO 表名(列名1, 列名2, ..., 列名n) VALUES(值1, 值2, ..., 值n);
</code></pre><p>eg:</p><pre><code>INSERT INTO student(sno, sname, ssex, sage, sdept) VALUES('201215121', '李勇', '男', 20, '计算机系');
</code></pre><h2 id=删除数据-delete>删除数据 DELETE<a hidden class=anchor aria-hidden=true href=#删除数据-delete>#</a></h2><pre><code>DELETE FROM 表名 WHERE 条件;
</code></pre><p>eg:注意完整性约束, 删除主码时, 会删除相关的外码。</p><pre><code>DELETE FROM student WHERE sno = '201215121';
</code></pre><h2 id=更新数据-update>更新数据 UPDATE<a hidden class=anchor aria-hidden=true href=#更新数据-update>#</a></h2><pre><code>UPDATE 表名 SET 列名1 = 值1, 列名2 = 值2, ..., 列名n = 值n WHERE 条件;
</code></pre><p>eg:</p><pre><code>UPDATE student SET sdept = '电子系' WHERE sno = '201215121';
</code></pre><h2 id=查询数据-select>查询数据 SELECT<a hidden class=anchor aria-hidden=true href=#查询数据-select>#</a></h2><pre><code>SELECT (DISTINCT) 列名1, 列名2, ..., 列名n // 查询的列,DISTINCT 可选项,去重, 默认不去重
FROM 表名1, 表名2, ..., 表名n // 查询的表
WHERE 条件 // 查询条件
GROUP BY 列名1, 列名2, ..., 列名n // 分组
ORDER BY 列名1, 列名2, ..., 列名n; // 排序, 默认升序ASC, 降序加 DESC
</code></pre><p>eg:</p><pre><code>SELECT * FROM student WHERE sdept = '计算机系' ORDER BY sage DESC;
</code></pre><p>聚合函数:当聚合函数遇到空值时,会忽略该值。聚合函数只能用于 SELECT
语句和GROUP BY 和 HAVING 子句中。</p><ul><li><p>COUNT(列名): 计数。</p></li><li><p>SUM(列名): 求和。</p></li><li><p>AVG(列名): 平均值。</p></li><li><p>MAX(列名): 最大值。</p></li><li><p>MIN(列名): 最小值。</p></li></ul><p>eg:</p><pre><code>SELECT COUNT(*), AVG(sage) FROM student WHERE sdept = '计算机系';//查询计算机系学生人数和平均年龄
</code></pre><p>where 条件:</p><ul><li><p>列名 = 值: 等于。</p></li><li><p>列名 &lt;> 值: 不等于。</p></li><li><p>列名 > 值: 大于。</p></li><li><p>列名 &lt; 值: 小于。</p></li><li><p>列名 >= 值: 大于等于。</p></li><li><p>列名 &lt;= 值: 小于等于。</p></li><li><p>列名 BETWEEN 值1 AND 值2: 在值1和值2之间。</p></li><li><p>列名 NOT BETWEEN 值1 AND 值2: 不在值1和值2之间。</p></li><li><p>列名 AND 列名: 与。</p></li><li><p>列名 OR 列名: 或。</p></li><li><p>列名 IS NULL: 为空。</p></li><li><p>列名 IS NOT NULL: 不为空。</p></li><li><p>列名 IN (值1, 值2, ..., 值n): 在值1, 值2, ..., 值n中。</p></li><li><p>列名 LIKE 模式: 模糊查询。</p></li></ul><p>eg:</p><pre><code>SELECT sdept, COUNT(*), AVG(sage) FROM student WHERE sage &gt; 20 GROUP BY sdept HAVING COUNT(*) &gt; 2 ORDER BY sdept;//查询年龄大于20的学生各系人数和平均年龄, 人数大于2的系
</code></pre><p>字符匹配模式:在ASCII字符集中, 一个汉字占两个字符,
一个字母占一个字符。在GBK字符集中, 一个汉字占两个字符,
一个字母占一个字符。在UTF-8字符集中, 一个汉字占三个字符,
一个字母占一个字符。在UTF-16字符集中, 一个汉字占两个字符,
一个字母占两个字符。 通配符:</p><ul><li><p>%: 任意字符。</p></li><li><p>_: 单个字符。</p></li></ul><p>转义字符\:在模糊查询中, %和_是通配符, 如果要查询这两个字符,
需要使用转义字符。 eg:</p><pre><code>SELECT * FROM student WHERE sname LIKE '李%';//查询姓李的学生
</code></pre><p>GROUP BY 子句:对查询结果进行分组, 通常与聚合函数一起使用。 HAVING
子句:对分组后的结果进行筛选。</p><pre><code>SELECT 列名1, 列名2, ..., 列名n, 聚合函数1, 聚合函数2, ..., 聚合函数n
FROM 表名1, 表名2, ..., 表名n
WHERE 条件
GROUP BY 列名1, 列名2, ..., 列名n
HAVING 条件
</code></pre><p>eg:</p><pre><code>SELECT sdept, COUNT(*), AVG(sage) FROM student GROUP BY sdept HAVING COUNT(*) &gt; 2 ORDER BY sdept;//查询各系人数和平均年龄, 人数大于2的系
</code></pre><p>ORDER BY 子句:对查询结果进行排序。</p><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1, 表名2, ..., 表名n
WHERE 条件
ORDER BY 列名1, 列名2, ..., 列名n;
</code></pre><p>eg:</p><pre><code>SELECT * FROM student ORDER BY sage DESC;//按年龄降序排序
</code></pre><h2 id=连接查询>连接查询<a hidden class=anchor aria-hidden=true href=#连接查询>#</a></h2><p>两表连接查询:</p><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1, 表名2
WHERE 表名1.列名 = 表名2.列名;
</code></pre><p>eg:</p><pre><code>SELECT student.sno, student.sname, student.sdept, course.cname, score.degree FROM student, course, score WHERE student.sno = score.sno AND course.cno = score.cno;//查询学生的学号, 姓名, 课程名, 成绩
</code></pre><p>单表自连接查询:</p><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1 别名1, 表名1 别名2
WHERE 别名1.列名 = 别名2.列名;
</code></pre><p>eg:</p><pre><code>SELECT a.sno, a.sname, b.sname FROM student a, student b WHERE a.sdept = b.sdept AND a.sname &lt;&gt; b.sname;//查询同系不同名的学生
</code></pre><p>外连接查询:</p><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1 LEFT JOIN 表名2 ON 表名1.列名 = 表名2.列名;
</code></pre><p>eg:</p><pre><code>SELECT student.sno, student.sname, score.degree FROM student LEFT JOIN score ON student.sno = score.sno;//查询学生的学号, 姓名, 成绩
</code></pre><h2 id=嵌套查询>嵌套查询<a hidden class=anchor aria-hidden=true href=#嵌套查询>#</a></h2><h3 id=子查询>子查询<a hidden class=anchor aria-hidden=true href=#子查询>#</a></h3><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名
WHERE 列名 IN (SELECT 列名 FROM 表名 WHERE 条件);
</code></pre><p>eg:</p><pre><code>SELECT * FROM student WHERE sdept IN (SELECT sdept FROM student WHERE sname = '李勇');//查询和李勇同系的学生
</code></pre><h3 id=比较子查询>比较子查询<a hidden class=anchor aria-hidden=true href=#比较子查询>#</a></h3><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1
WHERE 列名 运算符 (SELECT 列名 FROM 表名2 WHERE 条件);
</code></pre><p>eg:</p><pre><code>SELECT * FROM student WHERE sage &gt; (SELECT AVG(sage) FROM student WHERE sdept = '计算机系');//查询计算机系年龄大于平均年龄的学生
</code></pre><h3 id=连接子查询>连接子查询<a hidden class=anchor aria-hidden=true href=#连接子查询>#</a></h3><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1
WHERE EXISTS (SELECT * FROM 表名2 WHERE 条件);
</code></pre><p>eg1:在SC表中查询至少选修了1号学生选修的全部课程(Cno)的学生的学号(Sno)。</p><pre><code>SELECT DISTINCT Sno
FROM SC WHERE EXISTS 
(SELECT * FROM SC WHERE SC.Sno = Sno AND SC.Cno = 1); //查询至少选修了1号学生选修的全部课程的学生的学号
</code></pre><h2 id=集合查询>集合查询<a hidden class=anchor aria-hidden=true href=#集合查询>#</a></h2><h3 id=union>UNION<a hidden class=anchor aria-hidden=true href=#union>#</a></h3><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1
UNION
SELECT 列名1, 列名2, ..., 列名n
FROM 表名2;
</code></pre><p>eg:</p><pre><code>SELECT sno FROM student WHERE sdept = '计算机系' UNION SELECT sno FROM student WHERE sdept = '电子系';//查询计算机系和电子系的学生学号
</code></pre><h3 id=intersect>INTERSECT<a hidden class=anchor aria-hidden=true href=#intersect>#</a></h3><pre><code>SELECT 列名1, 列名2, ..., 列名n
FROM 表名1
INTERSECT
SELECT 列名1, 列名2, ..., 列名n
FROM 表名2;
</code></pre><p>eg:</p><pre><code>SELECT sno FROM student WHERE sdept = '计算机系' INTERSECT SELECT sno FROM student WHERE sdept = '电子系';//查询计算机系和电子系的学生学号
</code></pre><h2 id=view-视图>VIEW 视图<a hidden class=anchor aria-hidden=true href=#view-视图>#</a></h2><p>视图是一个虚拟表, 由一个或多个表的行或列组成, 与基本表不同,
视图不存储数据,
而是根据定义视图的查询语句动态生成数据,无法对视图进行增删改操作。</p><pre><code>CREATE VIEW 视图名 AS SELECT 列名1, 列名2, ..., 列名n FROM 表名1, 表名2, ..., 表名n WHERE 条件;
</code></pre><p>eg:</p><pre><code>CREATE VIEW student_view AS SELECT sno, sname, ssex, sage, sdept FROM student WHERE sdept = '计算机系';//创建计算机系学生视图
</code></pre><h1 id=事务调度>事务调度<a hidden class=anchor aria-hidden=true href=#事务调度>#</a></h1><h2 id=事务调度的准则>事务调度的准则<a hidden class=anchor aria-hidden=true href=#事务调度的准则>#</a></h2><ol><li><p>一组事务的调度必须保证:</p><ol><li><p>包含的每个事务的操作指令.</p></li><li><p>事务的操作指令的执行顺序.</p></li></ol></li><li><p>并行事务的调度必须保证:</p><ol><li><p>可串行化.</p></li><li><p>事务的操作指令的执行结果与它们在某个串行调度中的执行结果相同.</p></li></ol></li><li><p>判断一个调度是否可串行化的充分条件:</p><ol><li><p>冲突可串行化.</p></li><li><p>冲突操作: 两个事务中的操作指令, 一个读, 一个写,
且操作的数据对象相同.</p></li><li><p>一个调度是冲突可串行化的, 当且仅当它是冲突可串行调度.</p></li></ol></li></ol><h2 id=封锁>封锁<a hidden class=anchor aria-hidden=true href=#封锁>#</a></h2><ol><li><p>X锁: 读写锁, 用于写操作.</p></li><li><p>S锁: 读锁, 用于读操作.</p></li><li><p>封锁协议:</p><ol><li><p>一级封锁协议: 写前加X锁, 读写后解锁,可防止丢失更新.</p></li><li><p>二级封锁协议: 写前加X锁, 读前加S锁, 读完释放S锁,事务结束后解锁,
可防止丢失更新和读脏数据.</p></li><li><p>三级封锁协议: 读前加S锁, 读写前加X锁, 读写后解锁,
可防止丢失更新, 读脏数据和不可重复读.</p><p>注意:幻读和不可重复读的区别在于, 幻读是由于插入操作引起的,
不可重复读是由于更新操作引起的.</p></li></ol></li><li><p>两段锁协议(2PL): 事务的封锁和解锁操作必须在事务的开始和结束时进行.</p></li></ol><p>eg. A的初始值为20, B的初始值为10,
X,Y为临时变量,X=R(A)表示从A中读取数据到X中, X=X-10表示X减10,
W(A,X)表示将X写入A中, W(A，X)表示将X写入A中,
Y=R(B)表示从B中读取数据到Y中, Y=Y*X表示Y乘以X, W(B,Y)表示将Y写入B中.
事务T1和T2的操作序列如下:</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>X=R(A)</td><td></td></tr><tr><td>Y=R(B)</td><td></td></tr><tr><td></td><td>X=R(A)</td></tr><tr><td></td><td>X=X-10</td></tr><tr><td>X=X+Y</td><td></td></tr><tr><td></td><td>W(A,X)</td></tr><tr><td></td><td>Y=R(B)</td></tr><tr><td>W(A,X)</td><td></td></tr><tr><td></td><td>Y=Y*X;</td></tr><tr><td></td><td>W(B,Y)</td></tr></tbody></table><p>Q1:给出图中所示的执行结果(A,B的值),判定其是否正确,并说明理由.</p><p>最终结果,A=20,B=200.</p><p>Q2:加入适当的Xlock()和Unlock()操作,要求执行两段锁协议,且每个事务首条语句的请求时间与图示调度一致,请重写该调度,并给出执行结果.</p><p>调度表格如下:</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>Xlock(A)</td><td></td></tr><tr><td>X=R(A)</td><td></td></tr><tr><td></td><td>Xlock(A)</td></tr><tr><td>Xlock(B)</td><td></td></tr><tr><td>Y=R(B)</td><td></td></tr><tr><td>X=X+Y</td><td></td></tr><tr><td>W(A,X)</td><td></td></tr><tr><td>Unlock(A)</td><td></td></tr><tr><td>Unlock(B)</td><td></td></tr><tr><td></td><td>X=X-10</td></tr><tr><td></td><td>W(A,X)</td></tr><tr><td></td><td>Xlock(B)</td></tr><tr><td></td><td>Y=R(B)</td></tr><tr><td></td><td>Y=Y*X;</td></tr><tr><td></td><td>W(B,Y)</td></tr><tr><td></td><td>Unlock(A)</td></tr><tr><td></td><td>Unlock(B)</td></tr></tbody></table><p>最终结果,A=20,B=200.</p><h1 id=数据库设计>数据库设计<a hidden class=anchor aria-hidden=true href=#数据库设计>#</a></h1><h2 id=er图>ER图<a hidden class=anchor aria-hidden=true href=#er图>#</a></h2><p>实体为矩形，属性为椭圆，关系为菱形。联系用线连接实体和关系，表示实体间的联系。关系有一对一、一对多、多对多三种情况。</p><p><img alt=ER图 loading=lazy src=/studynotes/database/ER%E5%9B%BE.jpg></p><h3 id=例题>例题<a hidden class=anchor aria-hidden=true href=#例题>#</a></h3><p><img alt=ER图例题 loading=lazy src=/studynotes/database/ER%E5%9B%BE%E4%BE%8B%E9%A2%98.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lanshi.xyz/tags/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/>学习打卡</a></li><li><a href=https://lanshi.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li></ul><ul class=share-buttons></ul></footer><script src=https://giscus.app/client.js data-repo=lanshi47/Blog_comments data-repo-id=R_kgDOOBWQzw data-category=Announcements data-category-id=DIC_kwDOOBWQz84Cnc1e data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=fro data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://lanshi.xyz/>lanshi个人博客</a></span> ·</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=site-stats><div class=stat-item><span class=stat-label>访问量</span>
<span class=stat-number id=busuanzi_value_site_pv></span></div><div class=stat-item><span class=stat-label>访客数</span>
<span class=stat-number id=busuanzi_value_site_uv></span></div><div class=stat-item><span class=stat-label>文章数</span>
<span class=stat-number>1</span></div><div class=stat-item><span class=stat-label>运行时间</span>
<span class=stat-number id=site-runtime><span id=days>0</span>天
<span id=hours>00</span>:<span id=minutes>00</span>:<span id=seconds>00</span></span></div></div><script>(function(){const t=new Date("2025-02-25T00:00:00+08:00");function e(){const n=new Date,e=n-t,s=Math.floor(e/864e5),o=Math.floor(e%864e5/36e5).toString().padStart(2,"0"),i=Math.floor(e%36e5/6e4).toString().padStart(2,"0"),a=Math.floor(e%6e4/1e3).toString().padStart(2,"0");document.getElementById("days").textContent=s,document.getElementById("hours").textContent=o,document.getElementById("minutes").textContent=i,document.getElementById("seconds").textContent=a}e(),setInterval(e,1e3)})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>